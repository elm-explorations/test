module Test.Coverage.EdgeHitCounts exposing (EdgeHitCounts)

{-| Edge hit counts capture directed edges alongside code paths (basic blocks
instrumented with `let _ = Test.Coverage.track <pointId> in ...` by coverage
tooling).

(Heavily inspired by AFL: <https://lcamtuf.coredump.cx/afl/technical_details.txt>)

Being directed means, code paths A -> B -> C -> D and A -> C -> B -> D will
be considered different.

In spirit, this data structure could be thought of as

    type alias EdgeHitCounts =
        Dict ( Loc, Loc ) Int

    type alias Loc =
        -- the uniformly random pointId generated by coverage tooling
        Int

But in reality it's a JS TypedArray (fixed length, contiguous). Specifically,

    -- new Uint8ClampedArray(65536)



Each index in this array is a possible edge (modulo the array length),
calculated like this:



    {-
       currentLocation = // pointId we just hit, uniformly random 32bit integer
       edge = (currentLocation ^ previousLocation) % 65536; // index into the array!
       previousLocation = currentLocation >> 1; // this gives us the directionality
    -}

The array holds a counter for each edge (an 8bit unsigned integer, so 0..255)
that we increment whenever we hit that edge.

We'll get this EdgeHitCounts array for every input tested by a fuzz test, and
compare it against a global set of seen edges. Inputs can then be deemed
interesting (due to new paths uncovered) even if they don't cause a test to
fail. Interesting inputs get saved to the corpus and will later be mutated into
new inputs, which will eventually be picked by the machinery generating fuzz
test inputs.

There's a chance of collisions, but it was deemed acceptable. Can be tweaked
with the array size.

-}


type EdgeHitCounts
    = EdgeHitCounts Never

empty : 
